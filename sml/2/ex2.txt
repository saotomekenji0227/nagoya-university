課題1.[実行課題] 実行結果
Standard ML of New Jersey v110.80 [built: Mon Oct  3 11:18:46 2016]
- fun f x = (x,2);
val f = fn : 'a -> 'a * int
- fun g (x,y) = x + y;
val g = fn : int * int -> int
- f(g(1,2));
val it = (3,2) : int * int
- (f 1,f 2);
val it = ((1,2),(2,2)) : (int * int) * (int * int)
- g(f 1);
val it = 3 : int
- f(1,2);
val it = ((1,2),2) : (int * int) * int
- f(f 1);
val it = ((1,2),2) : (int * int) * int
- g f(1);
stdIn:9.1-9.7 Error: operator and operand don't agree [tycon mismatch]
  operator domain: int * int
  operand:         'Z -> 'Z * int
  in expression:
    g f

課題1.[実行課題] 考察
すべての実行について予想と同様の結果であった。
そのように動作した理由を各行について考察する。

f(g(1,2));
g(1,2)で1+2=3が実行され、fの引数が3となり実行された。
そのため結果は(3,2)となった。

(f 1,f 2);
f 1とf 2が実行され、その組が結果として出力された。
そのため結果は((1,2),(2,2))となった。

g(f 1);
f 1が実行されgの引数が(1,2)となった。
よってg(1,2)で1+2=3の計算が行われ結果は3となった。

f(1,2);
(1,2)を引数としてfが実行され実行結果は((1,2),2)となった。

f(f 1);
()内のf 1が実行され(1,2)となった。
(1,2)を引数としてfを実行したため一つ前の行と同様に結果は((1,2),2)となった。

g f(1);
左結合で関数が実行されるため、g(f(1))ではなくg(f)(1)の順で実行された。
関数fはgの引数に用いることが出来ないので、エラーが出力された。

課題2.[作成課題] 実行結果
val time = fn : ('a -> 'b) -> 'a -> 'b
val it = () : unit
- time fib 40;
1.539766 sec.
val it = 102334155 : int
- time twofib 40;
0.0 sec.
val it = (102334155,165580141) : int * int

課題2.[作成課題] 考察
fib及びtwofibをそれぞれ引数40としてtime関数で実行した。
その結果、fibの実行時間が1.539766秒、twofibの実行時間が0.0秒と計測された。
fibの計測結果からtime関数では10^-6秒を測定できると考えられる。
そのため、40を引数とした際のtwofibの実行時間は1.0*10^6秒より短いと考えられる。
以上のことから、twofibはfibと比較し有意に差のある高速化が行えているといえる。
理由としては、fibで行われている無駄な演算、つまり同じ演算を繰り返し行う操作がtwofibでは行われないため高速になったのだと考えられる。

課題3.[作成課題] 実行結果
Standard ML of New Jersey v110.80 [built: Mon Oct  3 11:18:46 2016]
- [opening /tmp/emacs-region41341zB]
val sn1 = fn : int -> int
val sn2 = fn : int -> int
val it = () : unit
- sn1 5;
val it = 15 : int
- sn2 5;
val it = 35 : int

課題3.[作成課題] 考察
sn1がテキストおける1つ目の数列、sn2が2つ目の数列である。
具体的には
sn1 = 1+2+...+n
sn2 = 1+(1+2)+(1+2+3)+...+(1+2+...+n)　である。

まず、sn1について考察する。sn1は等差数列の和であり、その値はn(n+1)/2で計算できる。
この式でn=5の計算を行うと5*6/2=15となる。それに対して本プログラムで利用した漸化式を以下に示す。

S1(n) = 1 ... n=1
   = S1(n-1)+n ... その他

この漸化式によりプログラムで計算を行った結果、15と出力された。
これは等差数列の和であることを利用した計算と同じ結果であるため、漸化式は正しく、かつプログラムは正常に動作していると考えられる。

次に、sn2について考察する。
この式においてn=5で計算するとS5=1+3+6+10+15=35となる。以下に本プログラムで実行した漸化式を示す。

S2(n) = S1(1) ... n=1
      = S2(n-1)+S1(n) ...その他

この漸化式によりプログラムで計算を行った結果35と出力された。
そのまま式に代入して計算した結果と同様であるため、この漸化式は正しくプログラムは正常に動作していると考えられる。
